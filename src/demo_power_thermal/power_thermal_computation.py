import numpy as np

SIGMA = 5.670374419 * 10 ** (-8)  # (W / (m2 X K^4)

SUN_POWER = 1376  # (W / m2)
SOLAR_CELL_EFF = 0.3  # 30%

# @TODO add references
LUNAR_ALPHA = 0.75
LUNAR_EPSILON = 0.8

PANEL_ALPHA = 0.9  # solar cell azurspace = 0.91
PANEL_ALPHA *= 0.5  # assuming half is not covered by solar cell but radiator material to reduce temperature
PANEL_EPSILON = 0.9

# https://ntrs.nasa.gov/api/citations/19840015630/downloads/19840015630.pdf
SUPPORT_ALPHA = 0.88
SUPPORT_EPSILON = 0.88

# Example Sun elevation and azimuth data for a lunar day at mid-latitude landing site
SUN_AZ = [
    89.9281395,
    96.490749,
    105.783472,
    115.737044,
    126.764722,
    139.261273,
    153.464699,
    169.203174,
    185.701194,
    201.797724,
    216.543471,
    229.58089,
    241.047242,
    251.307965,
    260.777898,
    269.855456,
]
SUN_EL = [
    0,
    5.937528,
    14.040576,
    21.762088,
    28.823323,
    34.867925,
    39.45594,
    42.119376,
    42.510898,
    40.576567,
    36.587823,
    30.996039,
    24.261371,
    16.768289,
    8.817421,
    0,
]


def compute_power(dot_products, cell_area):
    """
    Compute the power generation of solar cells.

    This function calculates the power generated by solar cells based on the solar flux, the dot products of the
    incident sunlight direction vectors and the normal vectors of the solar cell surfaces, the
    area of the solar cells, and the efficiency of the solar cells.

    Args:
        dot_products (numpy.ndarray): Array of dot products between the sunlight direction vectors
                                      and the normal vectors of the solar cell surfaces.
        cell_area (float): The area of the solar cells in square meters.

    Returns:
        numpy.ndarray: Array of power generation values for each solar cell.
    """

    power_generation = SUN_POWER * cell_area * np.abs(dot_products) * SOLAR_CELL_EFF
    return power_generation


def compute_thermal_surface(dot_products, normals, alpha, epsilon):
    # @TODO add alpha and epsilon as arguments
    """
    Compute the lunar surface temperatures assuming each sub-face is independent due to low conductivity.

    Parameters:
    dot_products (numpy.ndarray): Array of dot products between surface normals and the direction of incoming solar radiation.
    normals (numpy.ndarray): Array of surface normals.

    Returns:
    numpy.ndarray: Array of computed surface temperatures.

    Notes:
    - The temperature calculation is based on the balance of incoming solar radiation and outgoing thermal radiation.
    - Temperatures are computed in Kelvin.
    - Any infinite temperatures resulting from division by zero are set to NaN.
    """
    # @TODO add view factor adjustment?
    q_sun = np.abs(dot_products) * alpha * SUN_POWER  # (per unit surface)

    # Note: use clip so that negative dotproducts are zeroed out
    # @TODO replace clip by np.abs?
    # @TODO add view factor adjustment?
    n_space = [0, 0, 1]
    q_space = (
        np.clip(np.dot(normals, n_space), 0, None) * epsilon * SIGMA
    )  # (per unit surface and without T^4 term).

    temperatures = (q_sun / q_space) ** (1 / 4)
    temperatures[np.isinf(temperatures)] = np.nan
    return temperatures


def compute_thermal_node(sun_dot_products, areas, normals, alpha, epsilon):
    """
    Compute the temperature of a high conductivity node based on solar and space radiative heat fluxes at each sub-face.

    Parameters:
    sun_dot_products (numpy.ndarray): Dot products of the Sun direction vector with surface normals.
    areas (numpy.ndarray): Surface areas of the nodes.
    normals (numpy.ndarray): Normal vectors of the surfaces.
    alpha (float): Absorptivity of the surface.
    epsilon (float): Emissivity of the surface.

    Returns:
    float: Computed temperature of the node.
    """

    # @TODO add view factor adjustment?
    q_sun = np.abs(sun_dot_products) * areas * alpha * SUN_POWER

    n_space = [0, 0, 1]
    view_fact_space = np.dot(normals, n_space)
    negative_mask = view_fact_space < 0
    view_fact_space = 0.5 + 0.5 * view_fact_space
    view_fact_space[negative_mask] = 0
    assert np.all(
        (view_fact_space >= 0) & (view_fact_space <= 1)
    ), f"view factors are not between 0 and 1"
    q_space = view_fact_space * areas * epsilon * SIGMA

    temperature = (np.nansum(q_sun) / np.sum(q_space)) ** (1 / 4)
    return temperature
